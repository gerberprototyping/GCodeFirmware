#include "Cartesian.h"




template<typename T>
AbstractPoint<T>::AbstractPoint(T _x, T _y, T _z)
    : CartesianGeneric<T>(_x, _y, _z)
{}


template<typename T>
AbstractPoint<T> AbstractPoint<T>::fromMM(CartesianGeneric<double> &C) {
    return AbstractPoint<T>(C.getX()*STEPS_PER_MM, C.getY()*STEPS_PER_MM, C.getZ()*STEPS_PER_MM);
}


template<typename T>
AbstractPoint<T> AbstractPoint<T>::fromMM(double _x, double _y, double _z) {
    return AbstractPoint<T>(_x*STEPS_PER_MM, _y*STEPS_PER_MM, _z*STEPS_PER_MM);
}


template<typename T>
AbstractPoint<T> AbstractPoint<T>::fromSteps(CartesianGeneric<int64_t> &C) {
    return AbstractPoint<T>(C.getX(), C.getY(), C.getZ());
}


template<typename T>
AbstractPoint<T> AbstractPoint<T>::fromSteps(int64_t _x, int64_t _y, int64_t _z) {
    return AbstractPoint<T>(_x, _y, _z);
}




template<typename T>
CartesianDouble AbstractPoint<T>::toMM() const {
    CartesianDouble mm = CartesianDouble(*this);
    mm /= STEPS_PER_MM;           // do algebra using doubles
    return mm;
}


template<typename T>
CartesianInt AbstractPoint<T>::toSteps() const {
    return CartesianInt(getX(),getY(),getZ());
}




template<typename T>
double AbstractPoint<T>::getXMM() const {
    return getX() / STEPS_PER_MM;
}


template<typename T>
double AbstractPoint<T>::getYMM() const {
    return getY() / STEPS_PER_MM;
}


template<typename T>
double AbstractPoint<T>::getZMM() const {
    return getZ() / STEPS_PER_MM;
}


template<typename T>
int64_t AbstractPoint<T>::getXSteps() const {
    return getX();
}


template<typename T>
int64_t AbstractPoint<T>::getYSteps() const {
    return getY();
}


template<typename T>
int64_t AbstractPoint<T>::getZSteps() const {
    return getZ();
}


template<typename T>
void AbstractPoint<T>::setXMM(double _x) {
    x = _x * STEPS_PER_MM;
}

template<typename T>
void AbstractPoint<T>::setYMM(double _y) {
    y = _y * STEPS_PER_MM;
}

template<typename T>
void AbstractPoint<T>::setZMM(double _z) {
    z = _z * STEPS_PER_MM;
}

template<typename T>
void AbstractPoint<T>::setXSteps(int64_t _x) {
    x = _x;
}

template<typename T>
void AbstractPoint<T>::setYSteps(int64_t _y) {
    y = _y;
}

template<typename T>
void AbstractPoint<T>::setZSteps(int64_t _z) {
    z = _z;
}

